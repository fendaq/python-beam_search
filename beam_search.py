#!/usr/bin/env python
import numpy as np
from language_model import *
gram1_map = {}  
gram2_map = {}
gram3_map = {}
backoff2_map = {}
SEP = ' '
def beam_search(prob, beam_width=1000, top_paths=1, merge_repeated=True):
    paths_prob = {'40': 1.0}
    height, width = prob.shape
    
    for i in range(width):
        print 'step: ', i
        probi = prob[:,i]
        topk_index = np.argsort(probi)[-1 * 20 : ].tolist() #only expand topk node
        topk_index.reverse()
        paths_prob_expand = {}
        for path in paths_prob:
            prob_path = paths_prob[path]
            for k in topk_index:
                prob_k = probi[k]
                path_new = path + '%s%d' % (SEP, k) 
                prob_new = prob_k * prob_path
                if path_new in paths_prob_expand:
                    paths_prob_expand[path_new] += prob_new 
                else:
                    paths_prob_expand[path_new] = prob_new
                
        sorted_pairs = sorted(paths_prob_expand.items(), key = lambda x: x[1], reverse = True)
        if len(sorted_pairs) > beam_width:
            sorted_pairs = sorted_pairs[ : beam_width]
        paths_prob = dict(sorted_pairs) 
    
    result = {}
    for path in paths_prob:
        merge_path = joint(path) #delete duplicate phone
        if merge_path in result: #merge same paths
            result[merge_path] += paths_prob[path]
        else:
            result[merge_path] = paths_prob[path]
    
    sortresult = sorted(result.items(), key = lambda x : x[1], reverse = True)
    print sortresult[0]    

def get_lm_logprob(seq):
    tmp = seq.split(' ')[-3 : ]
    if len(tmp) < 2:
        return 0
    seq = ' '.join(tmp)
    if seq in gram3_map:
        return gram3_map[seq]
    seq = ' '.join(tmp[-2 : ])
    if seq in gram2_map:
        if seq in backoff2_map:
            return gram2_map[seq] + backoff2_map[seq]
        else:
            return 0
    else:
        return 0
    
def beam_search_with_lm(prob, beam_width=1000, alpha = 0.01, top_paths=1, merge_repeated=True):
    paths_prob = {'40': 1.0}
    height, width = prob.shape
    #expand frame by frame 
    for i in range(width):
        print 'step: ', i
        probi = prob[:,i]
        topk_index = np.argsort(probi)[-1 * 20 : ].tolist() #only expand topk node
        topk_index.reverse() #prob decrease
        paths_prob_expand = {}
        #iterate all paths generated by previous step
        for path in paths_prob:
            prob_path = paths_prob[path]
            for k in topk_index: #expand topk node
                prob_k = probi[k]
                path_new = path + '%s%d' % (SEP, k) 
                prob_new = prob_k * prob_path

                lm_prob = 1.0
                if i > 2:
                    lm_prob = get_lm_logprob(path_new)

                prob_new = (1 - alpha) * prob_new + alpha * pow(10, lm_prob)

                if path_new in paths_prob_expand:
                    paths_prob_expand[path_new] += prob_new 
                else:
                    paths_prob_expand[path_new] = prob_new
                
        sorted_pairs = sorted(paths_prob_expand.items(), key = lambda x: x[1], reverse = True)
        if len(sorted_pairs) > beam_width:
            sorted_pairs = sorted_pairs[ : beam_width]
        paths_prob = dict(sorted_pairs) 
    
    result = {}
    for path in paths_prob:
        merge_path = joint(path) #delete duplicate phone
        if merge_path in result: #merge same paths
            result[merge_path] += paths_prob[path]
        else:
            result[merge_path] = paths_prob[path]
    
    sortresult = sorted(result.items(), key = lambda x : x[1], reverse = True)
    print sortresult[0]    

def joint(line):
    if line and len(line) == 0:
        return None
    if line.startswith(SEP):
        line = line[1:]
    phonelist = []
    templist = line.split(SEP)
    lastphone = ''
    for phone in templist:
        if phone == lastphone:
            continue
        else:
            phonelist.append(phone)
            lastphone = phone
    return ' '.join(phonelist).replace(' 39', '') 

def build_prob(inpath):
    reader = open(inpath, 'r')
    lines = reader.readlines()
    lines = lines[1:]
    frames = []
    for line in lines:
        nums = [float(num) for num in line.strip().split('\t')]
        frames.append(nums)
    return np.array(frames)


if __name__ == '__main__':
    inpath = '34.prob.txt'
    lm_path = 'lls_libris_o3.txt'
    global gram1_map
    global gram2_map
    global gram3_map
    global backoff2_map

    prob = build_prob(inpath)    
    gram1_map, gram2_map, gram3_map, backoff2_map = load_model(lm_path)
    print prob.shape
    beam_search_with_lm(prob.transpose(), alpha = 0.01) 
